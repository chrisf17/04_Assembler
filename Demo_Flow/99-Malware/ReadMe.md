# Basic Malware Analysis

## Tracing syscalls

`strace` is a diagnostic, debugging, and troubleshooting tool in Linux that traces system calls made by a program. System calls (syscalls) are requests a program makes to the Linux kernel to perform low-level operations, such as reading from or writing to files, allocating memory, managing processes, or interacting with devices.

- **Monitor System Calls**: `strace` logs every system call your assembly program makes, such as `open`, `write`, `read`, `close`, and more.
- **Detect Failures**: If a system call in your assembly program fails (e.g., due to incorrect arguments or file permissions), `strace` shows the error codes and messages (`EACCES`, `ENOENT`, etc.) that explain why the call failed.
- **Follow Program Flow**: `strace` helps you trace the execution flow of your program, showing how system calls are chained together and how data moves through your application.
- **Debug Common Issues**: If your assembly program isn't working as expected (like failing to open a file or incorrectly writing data), `strace` allows you to pinpoint the exact syscall that's causing the problem and understand its behavior.


#### Use `strace` to Debug the Program:
To run the program under `strace` and trace all syscalls it makes, use:

```bash
strace ./demo
```

This will output all system calls made by the program, including `open`, `write`, `close`, and `exit`. For example, you might see something like this:

```text
execve("./write_to_file", ["./write_to_file"], 0x7fffae373710 /* 63 vars */) = 0
open("output.txt", O_WRONLY|O_CREAT|O_TRUNC, 0644) = 3
write(3, "Hello, world!\n", 14)          = 14
close(3)                                = 0
exit(0)                                 = ?
+++ exited with 0 +++
```

#### Interpreting the `strace` Output:
- **`open("output.txt", O_WRONLY|O_CREAT|O_TRUNC, 0644) = 3`**: The program successfully opened (or created) the file `output.txt` and returned file descriptor `3`.
- **`write(3, "Hello, world!\n", 14) = 14`**: The program wrote `14` bytes of data (`"Hello, world!\n"`) to file descriptor `3`.
- **`close(3) = 0`**: The file was successfully closed.
- **`exit(0)`**: The program exited successfully.

#### Example Debugging Scenario:
If the `open` call fails due to a missing file or wrong permissions, `strace` would show:

```text
open("output.txt", O_WRONLY|O_CREAT|O_TRUNC, 0644) = -1 EACCES (Permission denied)
exit(1)
```

This indicates that the program tried to open the file but failed because of a permissions issue (`EACCES`), helping you quickly identify and resolve the problem.

## Disassembling an application for malware analysis

Certainly! When performing malware analysis, **`objdump`** is one of the core tools used to disassemble binaries and view their low-level instructions. `objdump` helps reverse-engineers understand how a program operates at the assembly level. For those more familiar with Intel syntax (as opposed to the default AT&T syntax), `objdump` can be configured to display disassembly in Intel syntax.

Here’s how to use `objdump` with **Intel syntax** to analyze malware and how this information can be useful for reverse engineering.

### What is `objdump`?

`objdump` is a command-line tool used to display information about object files or executable binaries. It can:
- **Disassemble machine code** into human-readable assembly instructions.
- **Dump sections** of the binary (such as `.text`, `.data`, `.bss`).
- **Analyze symbol tables** to see functions and variables.

### Using `objdump` in Intel Syntax for Malware Analysis

By default, `objdump` outputs in **AT&T syntax**, which can be less familiar to some. You can specify **Intel syntax** for disassembly using the `-M intel` option.

#### Example Workflow: Using `objdump` to Disassemble Malware in Intel Syntax

Let’s say you have a malware binary named `malware_sample`, and you want to disassemble and analyze it.

#### Step 1: Disassemble the Malware Binary in Intel Syntax

```bash
objdump -d -M intel ./malware_sample
```

- **`-d`**: Disassembles the executable sections of the binary (typically the `.text` section where the code resides).
- **`-M intel`**: Specifies Intel syntax for the output, which is typically easier to read for those more familiar with Intel-style assembly.

#### Sample Output in Intel Syntax:

```asm
08048340 <_start>:
 8048340:       xor    ebp, ebp
 8048342:       mov    ecx, esp
 8048344:       sub    esp, 0x10
 8048347:       mov    DWORD PTR [esp], 0x8048450
 804834e:       call   8048310 <func>
 8048353:       mov    eax, 0x1
 8048358:       int    0x80

08048310 <func>:
 8048310:       push   ebp
 8048311:       mov    ebp, esp
 8048313:       sub    esp, 0x8
 8048316:       mov    eax, 0x0
 804831b:       leave
 804831c:       ret
```

#### Explanation of the Output:

- **`08048340 <_start>`**: This is the entry point of the program. The address `08048340` is where the first instruction of the program resides.
- **`xor ebp, ebp`**: Zeroes out the `ebp` register, which is often used to set up stack frames.
- **`mov ecx, esp`**: Moves the current stack pointer (`esp`) into the `ecx` register.
- **`sub esp, 0x10`**: Allocates space on the stack (common in function prologues).
- **`call 8048310 <func>`**: Calls a function located at memory address `08048310`.
- **`mov eax, 0x1`**: Sets up the system call number for `sys_exit` (1) to exit the program.
- **`int 0x80`**: Executes the system call (in this case, `sys_exit`).

In this example, the binary sets up a simple program that performs a function call and exits. By viewing this disassembly, you can understand the program's control flow.

### Step 2: Analyze Other Sections (e.g., `.data`)

In addition to the `.text` section (which contains code), malware often manipulates data stored in other sections, such as `.data` (initialized data) or `.rodata` (read-only data, like strings).

To inspect a specific section, such as `.data`, use:

```bash
objdump -s -j .data ./malware_sample
```

This command dumps the contents of the `.data` section in hexadecimal and ASCII:

#### Sample Output:
```text
Contents of section .data:
 8049500 48656c6c 6f2c2077 6f726c64 21000000  Hello, world!...
 8049510 01000000 02000000                    ............
```

- The string `"Hello, world!"` is stored in the `.data` section, often seen in malware to embed messages or data.
- Numbers like `01000000` and `02000000` could represent integer values stored in memory.

### How This Helps with Malware Analysis:

- **Revealing Code Logic**: Disassembling the binary in Intel syntax helps you read the low-level logic of the malware. You can track how functions are called, system calls are made, and control flow is handled.
- **Identifying Malicious Behavior**: Looking at specific system calls (`int 0x80` in Linux, for example), you can see what the malware does—whether it's reading files, writing files, creating network connections, or injecting code into processes.
- **Inspecting Embedded Data**: The `.data` and `.rodata` sections often store sensitive data like encryption keys, IP addresses, command-and-control (C2) URLs, or malicious payloads. Inspecting these sections helps reverse-engineers locate this data.

### Step 3: Analyze System Calls

Malware frequently makes system calls to interact with the operating system. You can search for common system calls by disassembling the `.text` section.

Example:

- **`int 0x80`**: In Linux, this triggers a system call, and the value in the `eax` register determines which system call is made. For example:
  - `eax = 1`: `sys_exit` (program exit).
  - `eax = 4`: `sys_write` (write to a file descriptor).
  - `eax = 5`: `sys_open` (open a file).

By examining the `eax` register before `int 0x80`, you can understand which system calls the malware is making.

#### Example:

```asm
08048400:   mov    eax, 5          ; sys_open
08048405:   mov    ebx, 0x8048580  ; filename
0804840a:   int    0x80            ; Make system call
```

Here, the malware is attempting to open a file (`sys_open`).

### Additional Useful Options for `objdump`:

- **`objdump -t ./malware_sample`**: Displays the symbol table, which can help locate functions and variables.
- **`objdump -x ./malware_sample`**: Displays headers, including section headers, which helps in understanding how the program is structured.
- **`objdump -D -M intel ./malware_sample`**: Disassembles all sections of the binary (not just the `.text` section).

## More Advanced Analysis

More advanced tools are available for malware analysis. A more Powerful disassembler is called IDA availbale at https://hex-rays.com/ida-free

This tool will be covered in more detail in the Malware Analysis section of the Embedded systems module in year 2.

Other tools you will use include:

* Dependency Walker
* BinText
* VirusTotal - https://www.virustotal.com/gui/home/upload
* UPX (Executable packer/unpacker) - https://upx.github.io/

